# Zookeepr Session

    Sesions offer order guarantees, which mean that requests in a session are 
  executed in FIFO order. Typically, a client has only a single session open, so
  its request are all executed in FIFO order. If a client has multiple concurrent
  sessions, FIFO ordering is not necessarily perserved across the sessions.
  Consecutive sessions of the same client, even if they don't overlap in time,
  also do not necessarily preserve FIFO order. Here is how it can happen in this
  case:
    1. Client establishs a session and makes two consecutive asynchronous calls
    to create /tasks and /workers.
    2. First session expires.
    3. Client establishes another session and makes an asynchronous call to 
    create /assign.
    In this sequence of calls, it is possible that only /tasks and /assign have
   been created, which preserves FIFO ordering for the first session but violates
   it across sessions.
   
# Implementing a primitive : locks with ZooKeeper

    ONe simple example of what we can do with ZooKeeper is implement critical 
  sections through locks. There care multiple flavors of locks(e.g., read/write
  locks, global locks) and serveral ways to implement locks with ZooKeeper. Here
  we discuss a simple recipe just to illustrate how applications can use ZooKeeper;
  we do not consider other variants of locks.
    Say that we have an application with n Processes trying to acquire a lock.
  Recall that ZooKeeper does not expose primitives directly, so we need to use 
  the ZooKeeper interface to manipulate zondes and implement the lock. To acquire
  a lock,each process p tries to create a znode, say /lock. If p succeeds in 
  creating the znode, it has the lock and can proceed to execute its critical 
  section. One potential problem is that p could crash and never release the lock
  In this case, no other process will ever be able to acquire the lock again, and
  the system could seize up in a deadlock. To avoid such situation, we just have
  to make the /lock znode ephemeral when we create it.
    Other process that try to create /lock fail so long as the znode exists. So,
  they watch for changes to /lock and try to acquire the lock again once they 
  detect that /lock has been deleted. Upon receiving a notificaiton that /lock 
  has been deleted, if a process p' is still interested in acquiring the lock, 
  it repeats the steps of attempting to create /lock and, if another process has
  created the zonde already,watching it.
  
# ZooKeeper Manages Connections
  
   Don't try to manage ZooKeeper client connections yourself. The ZooKeeper 
 client library monitors the connecton to the service and not only tells your 
 about connection problems, But actively tries to reestablish communication. 
   Often the library can quickly reestablish the session with minimal disruption
 to your application. Needlessly closing and starting a new session just causes
 more load on the system and longer availability outages.
   Of course, the client will continually extend the expiration time as long as 
 it keeps an active connection to a ZooKeeper server.
   Once close is called, the session represented by the ZooKeeper object gets 
 destoryed.
 
# ConnectionLossException

    The ConnectionLossException occurs when a client becomes disconnected from a
  ZooKeeper server. This is usually due to a network error, such as a network 
  partition, or the failure of a ZooKeeper server. When this exception occurs, it
  is unknown to the client whether the request was lost before the ZooKeeper 
  servers processed it, or if they processed it but the client did not receive 
  the response. As we described earlier, the ZooKeeper client library will 
  reestablish the connection for future request, but the process must figure out
  whether a pending request has been processed or whether it should reissue the 
  request.
  
# InterruptedException

    The InterruptedException is caused by a client thread calling Thread.interrupt.
  This is often part of applicaiton shutdown, but it may also be used in other 
  application-dependent ways. This exception literally interrupts the local client
  request processing in the process and leaves the request in an unknown state.
    Unfortunately, in Java there aren't clear guidelines for how to deal with 
  thread interruption, or even what it means. Sometimes the interruptions are 
  used to signal threads that things are being shutdown and they need to clean up.
  In other cases, an interruption is used to get control of a thread, but execut-
  ion of the applicaition continues.
    Handling of InterruptedExcetion depends on our context. If the interrupteEx-
  pection will bubble up and eventually close our zk handle, we can let it go up
  the stack and everything will get cleaned up when the handle is closed. If the
  zk handle is not closed, we need to figure out if we are the master before re-
  throwing the exception or asynchronously continuing the operation. This latter 
  cause is particularly tricky and requires careful design to handle properly.
  
 # ZooKeeper Asynchronously request / callback
 
     The asynchronous method simpley queues the request to the ZooKeeper server.
   Transmission happens on another thread. When responses are recevied, they are
   processed on a dedicated callback thread. To preserve order, there a single 
   callback thread and responses are processed in the order they are recevied.
     Because a single thread process all callbacks, if a callback block, it blocks
   all callbacks that follow it. This means that generally you should not do 
   intensive operations or blocking operations in a callback. There may be times
   when it's legitimate to use the synchronous API in a callback, but it should
   generaly be avoided so that subsequent callbacks can be processed quickly.
   
# One-Time Triggers
      A watch is a one-time trigger associated with a znode and a type of event(e.g.
    , data is set in the znode, or the znode is deleted). When the watch the watch
    is triggered by an event, it generates a nitification. A notification is a 
    message to the application client that registered the watch to inform this 
    client of the event.
      When an application process regiesters a watch to recevie a notification,
    the watch is triggered at most once and upon the first event that matches the 
    condition of the watch. For example, say that the client needs to know when a 
    given znode /z is deleted(e.g., a backup master). The client executes an ex-
    ists operation on /z with the watch flag set and waits for the notification.
    The notification comes in the form of a callback to the application client.
      Each watch is associated with the session in which the client sets it. If
    the session expires, pending watches are removed. Watches do, however, persist
    across connections to different servers. Say that a ZooKeeper client disconnects
    from a ZooKeeper server and connects to a different server in the ensemble.
    The client will send a list outstanding watches. When reregiestering the 
    watch, the server will check to see if the watched znode has changed since
    the watch was regiested. If the znode has changed, a watch event will be sent
    to the client; otherwise, the watch will be reregiestered at the new server.
   
# Miss Events with One-time triggers

    An application can miss events between receiving a notification and register-
    ing for another watch. However, this issue deserves more discussion. Missing
    events is typically not a problem because any changes that have occurred dur-
    ing the period between receiving a notification and regiestering a new watch
    can be captured by reading the state of ZooKeeper directly.
    
# Watch Interface

    public void process(WatchEvent event);
    
    - The state of the ZooKeeper session(KeeperState):
      ```
        Disconnected
        SyncConnected
        AuthFailed
        ConnectedReadOnly
        SaslAuthenticated
        Expired
      ```
      
     - The event type(EventType)
       ```
         NodeCreated
         NodeDeleted
         NodeDataChanged
         NodeChildrenChanged
         None
       ```
       
     - A znode path in the case the watched event is not None
     
     - One important observation about watches is that currently it is not poss-
     ible to remove them once set. The only two to remove a watch are to have it
     triggered or for its session to be cloused or expired. This behavior is li-
     kely to change in future versions, however, because the community has been
     working on it for version 3.5.0.
     
# Multiop

    Multiop was not in the original design of ZooKeeper, but was added in version
  3.4.0. Multiop enables the execution of multiple ZooKeeper operations in a  
  block atomically. The execution is atomic in the sense that either all opera-
  tions in a multiop block succeed or all fail. For example, we can delete a pa-
  rent zonde and its child in a multiop block. The only possible outcomes are 
  that either both operations successd or both fail. It is not possible for the
  parent to be deleted while leaving one of its hcildren around, or vice versa.
    Multiop can simplify our master-worker implementation in at least one plcae.
  When assiging a task, the master in previous examples has created the corres-
  ponding assignment znode and the deleted the task znode under /tasks. if the 
  master crashes before deleting the znode under /tasks, we are left with a task
  in /tasks that has already been assigned. Using multiop, we can create the 
  znode representing the assignment of the task under /assign and delete the 
  zonde representing the task unser /tasks atomically. Using this approach, we
  guarantee that no task znode under /tasks has been already assigned. If a 
  backup takes over the role of master, is is not necessary to disambiguate the
  tasks in /tasks: they are all unassigned.
    Another feature that multiop offers is the possibility of checking the 
  version of a znode to enable operations over multiple zondes that read the state
  of ZooKeeper and write back some data-possibly a modification of what has been
  read. The version of the znode that is checked does not change, so this call
  enables a multiop that checks the version of z znode that is not modified. This
  feature is useful when the changes to one or more znodes are conditional upon 
  the version of another znode. Say that in our master-worker example, the master
  needs to have the clients adding new tasks under a path that the master speifies.
  For example, the master could ask clients to create new task as children of 
  /tasks-mid, where mid is the master identifier. The master stores this path
  as the data of the /master-path znode. A client that needs to add a new task
  first reads /master-pth and picks its current version with Stat. Next, the client
  creates a new task zonde under /task-mid as part of the a multiop call. and it
  also checks that the version of /master-path matches the one it has read.
  
# Recoverable and Unrecoverable Failure

    Rather than trying to determine causes of failures, ZooKeeper expose two cla-
  sses of failure: recoverable and unrecoverable. Recoverable failures are trans-
  ient and should be considered relatively normal-things happen. Brief network 
  hiccups and server failures can cause these kinds of failures. Developers should
  write theire code so that theire applications keep running in spite of these
  failures.
    Unrecoverable failure are much more problematic. These kinds of failures cause
  the ZooKeeper handle to become inoperable. The easiest and most common way to 
  deal with this kind of failure is to exit the application. Examples of causes 
  of this class of failure are session timeouts, networks outages for longer than
  the session timeout, and authentication failures.
  
  
     

# references
 
  - ZooKeeper Distributed Process Coordination.O'Reilly.2013